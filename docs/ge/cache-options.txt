POC: Standing data cache на примере JBOSS Infinispan.

Цель POC:
    Выбрать опримальную топологию и конфигрурацию кеша кластера.
    Выбрать опримальные точки интеграции кеша в приложение (DAO / Service layer).
    Выбрать подход обеспечения консистентности и согласованности кешированных данных.
    Идентифицировать потенциалые узкие мест приложения и возможно найти способы их решения.

Проведение POC:
    Создать минимальное кластеризированное окружения на базе: vagrant, oracle vm, wildfly, infinispan, load balancing, PostgreSQL.
    Создать минимальное приложение по импорту XML на базе: Apache CXF, BPMN, Spring, Hibernate.
    Создать нагрузачные тесты и тестовый набор данных.
    Выбрать и оптимизировать конфигурацию и топологию кеша. Выбрать оптимальные токчи инеграции в приложение.

Результаты POC:
    Описание и метрики выбраной топологию и конфигрурацию кеша. Описание точек интеграции в приложение.
    Описание и метрики всех протестированных топологий и конфигураций.
    Шаблон для проведения измерений других топоплогий и конфигураций.

=======================================================================================================================



Что измерять?
    + Read latency - The average read latency (in milliseconds) per incoming read operation.
    Read ops - 	The total number of read operations.
    hit ratio h - установить порог и сделать нотификацию

=======================================================================================================================
Цель проведения POC.
    Выработать подход по сокращению времи выполнения BPMN процессов (import / validation / calculate / export / publish)
    увеличить пропускную способность BPMN процессов (import / validation / calculate / export / publish )
    сократить нагрузку на базу данных (disk IO)

НЕ является целью POC.
    сократить время ответа UI элементов

Результаты POC

    руководство по интеграции кластекра каше в приложение
    руководство по интеграции транзакций с кешем
    руководство/шаблоны по построению нагрузачных тестов

    метрики как изменяются пропускная способность приложения от топологии кластера кеш
    метрики по снижению использования дискового IO при использования кеша
    метрики изменения пропускной способности приложения с кешем и без
    получим шаблонны окружений для проведения POC

Где кешировать?
    on service level
        + хранить уже готовые объекты.
        + учитывать период вадиности объетка.

    on hibernate level
        + уже реализованно
        - прейдется хранить множество мелких сущностей
        - прейдется хранить связи между сущностями
        - прейдется обеспечивать их консистентность

    - on RPC level
    - on Client level

Что кешировать?
    standing data (отдельные сущности, результаты запросов сужностей)
    frequency used schedules for active period (schedules, результаты обеденений schedules Published ISP)

Как кешировать?
    in process cache (для standing data)
        + минимальное время ответа
        - нужна синхронная репликая для подержания консистентнотси.

    distributed cache
        + может заниматься не только хранением но обаботкой (использование мощностей серверов кеша)
        + есть встоенные механизмы подержания консистентности
        - временые задержки больше (сеть, сереализация и десериализация, задержки планировщика процесов)
        независимо мастабирутеся от приложения
        ? может хранить значительно больше данных

Что можем сделать в оффлаин режиме?
    создать класстерное виртуальное окружения (vagrant, oracle vm, wildfly, Infinispan, Load balancing)
    создать постейшее приложение по импорту XML с подержкой кеша в кластере (Spring, Hibernate, BPMN, Drools, CXF, Camel, PostgreSQL)
    создать нагрузочные тесты (измерить с/без кеширования)

    найти возможные точки интеграции кеширования в Drools, BPMN, CXF, Camel
    интегрировать кеш
    интегрировать кеш с транзакциями (2х фазные).
    настоить приложение для работы в кластере
    сгнерировать тестовый набор данных
    интегрировать сбор необходимых метрик

Дополнительные условия.
    транзакционнасть
    согласованость на все узлах кластера